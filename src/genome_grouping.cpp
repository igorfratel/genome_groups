#include "genome_grouping.h"

static std::vector<GenomicNeighborhood> parse_neighborhoods(std::string neighborhoods_filename) {
    /*Receives a file generated by parse_neighborhood.py.
    /*Returns a vector of genomic neighborhoods, filled with the information from the file.*/

    std::ifstream file;
    std::string token;
    std::string accession;
    std::string organism;
    std::string locus;
    std::string pid;
    std::string cds;
    std::vector<GenomicNeighborhood> neighborhoods;

    file.open(neighborhoods_filename.c_str());
        while(std::getline(file, token)) {
            //token is already the genus
            organism = token + ' ';
            std::getline(file, token); //species
            organism += token;
            std::getline(file, token); //accession
            accession = token;

            GenomicNeighborhood temp_neigh(accession, organism);

            while (std::getline(file, token) && token != "end") {
                if (token == "seed") {
                    std::getline(file, token); //locus from seed
                    locus = token;
                    std::getline(file, token); //pid from seed
                    pid = token;
                    std::getline(file, token); //cds from seed
                    cds = token;
                    temp_neigh.add_protein(locus, pid, cds);
                    temp_neigh.add_seed(locus, pid, cds);
                }
                else {
                    //token is already the locus
                    locus = token;
                    std::getline(file, token); //pid
                    pid = token;
                    std::getline(file, token); //cds
                    cds = token;
                    temp_neigh.add_protein(locus, pid, cds);
                }
            }
            neighborhoods.push_back(temp_neigh);
        }
        file.close();
    return neighborhoods;
}

void genome_clustering(std::string neighborhoods_filename, ProteinCollection &clusters,
                       std::string method, double stringency, std::string genome_sim_filename) {
    /*Receives a file containing all the genomic neighborhoods (as output by parse_neighborhood.py),
     *a ProteinCollection and the desired genomic neighborhood clustering method.
     *Writes the similarity between all genomic neighborhoods on the genome_sim_filename in
     *the format "organism1 acession1 coordinates1 organism2 acession2 coordinates2 score"*/

    std::ofstream file(genome_sim_filename.c_str());
    std::cout.precision(2); //configure output limiting to 2 decimal points
    std::vector<GenomicNeighborhood> neighborhoods = parse_neighborhoods(neighborhoods_filename);

    //DEBUG print the genomic neighborhoods we are considering
    /*for (int i = 0; i < neighborhoods.size(); i++) {
        std::cout << neighborhoods[i].get_accession() << " " << neighborhoods[i].get_organism() <<
                     " " << neighborhoods[i].protein_count() << "\n";
        for (GenomicNeighborhood::iterator it = neighborhoods[i].begin(); it != neighborhoods[i].end(); ++it) {
            std::cout << it->pid << " " << it->locus << " " << it->cds << "\n";
        }
    }
    std::cout << "\n"*/;
    if (method == "porthodom") {
        double score;
        for(unsigned int m = 0; m < neighborhoods.size(); m++) {
            for (unsigned int n = m + 1; n < neighborhoods.size(); n++) {
                score = porthodom_scoring(neighborhoods[m], neighborhoods[n], clusters, stringency);
                file << neighborhoods[m].get_organism() << " " <<
                        neighborhoods[m].get_accession() << " " <<
                        neighborhoods[m].get_cds_string() << " " <<
                        neighborhoods[n].get_organism() << " " <<
                        neighborhoods[n].get_accession() << " " <<
                        neighborhoods[n].get_cds_string() << " " <<
                        score << "\n";
            }
        }
    }

    else if (method == "porthodomO2") {
        double score;
        for(unsigned int m = 0; m < neighborhoods.size(); m++) {
            for (unsigned int n = m + 1; n < neighborhoods.size(); n++) {
                score = porthodomO2_scoring(neighborhoods[m], neighborhoods[n], clusters, stringency);
                file << neighborhoods[m].get_organism() << " " <<
                        neighborhoods[m].get_accession() << " " <<
                        neighborhoods[m].get_cds_string() << " " <<
                        neighborhoods[n].get_organism() << " " <<
                        neighborhoods[n].get_accession() << " " <<
                        neighborhoods[n].get_cds_string() << " " <<
                        score << "\n";
            }
        }

    }
}
